import logging
import concurrent.futures as cf

from abc import ABC, abstractmethod

from ..utils import protocol_version_conversion
from ..scan_parameters.connections.connection_utils import worst_or_best_protocol


class VulnerabilityTest(ABC):
    test_name = ''

    def __init__(self, supported_protocols, address, timeout, protocol):
        self.timeout = timeout
        self.address = address
        self.valid_protocols = []
        self.supported_protocols = supported_protocols
        self.protocol = protocol
        self.scan_once = True

    def scan(self):
        """
        Call the appropriate scan methods

        :return: Result of a scan
        :rtype: bool
        """
        logging.info(f'Testing for {self.test_name}...')
        switcher = {
            True: self.scan_for_protocol,
            False: self.scan_for_protocols
        }
        result = switcher[self.scan_once]()
        logging.info(f'{self.test_name} test done.')
        return result

    def scan_for_protocol(self):
        """
        Test the webserver for a vulnerability on a protocol versions

        :return: Whether a test was positive
        :rtype: bool
        """
        protocol = self.protocol
        if self.protocol not in self.valid_protocols:
            usable_protocols = list(filter(lambda p: p in self.valid_protocols, self.supported_protocols))
            protocol = worst_or_best_protocol(usable_protocols, False)
        protocol_to_test = protocol_version_conversion(protocol)
        result = self.test(protocol_to_test)
        return result

    def scan_for_protocols(self):
        """
        Test the webserver for a vulnerability on all valid protocol versions

        :return: Whether any test was positive
        :rtype: bool
        """
        usable_protocols = list(filter(lambda p: p in self.valid_protocols, self.supported_protocols))
        if len(usable_protocols) == 0:
            return False
        protocol_versions_numbers = list(map(protocol_version_conversion, usable_protocols))
        results = self.multithreading_tests(self.test, protocol_versions_numbers)
        return any(results)

    @staticmethod
    def multithreading_tests(function, protocol_binary_versions):
        """
        Run tests in parallel

        :param list protocol_binary_versions:
        :param function: Functions to be run
        :return: Results of the scans
        :rtype: list
        """
        # List that all the threads live
        futures = []
        results = []
        with cf.ThreadPoolExecutor(max_workers=len(protocol_binary_versions)) as executor:
            for version in protocol_binary_versions:
                # Submit test function
                futures.append(executor.submit(function, version))
            for done_future in cf.as_completed(futures):
                results.append(done_future.result())
        return results

    @abstractmethod
    def test(self, version):
        """
        Test the implemented vulnerability

        :param int version: SSL/TLS version to test on
        :return: Whether the test passed or not
        :rtype: bool
        """
        pass
