import logging
import concurrent.futures as cf

from abc import ABC, abstractmethod

from .utils import version_conversion


class VulnerabilityTest(ABC):
    test_name = ''

    def __init__(self, supported_protocols, address):
        self.timeout = 2
        self.address = address
        self.valid_protocols = []
        self.supported_protocols = supported_protocols

    def scan(self):
        """
        Test the webserver for a vulnerability on all valid protocol versions

        :return: Whether any test was positive
        :rtype: bool
        """
        logging.info(f'Testing for {self.test_name}...')
        to_test_protocols = list(filter(lambda protocol: protocol in self.valid_protocols, self.supported_protocols))
        if len(to_test_protocols) == 0:
            return False
        binary_protocol_versions = list(map(lambda p: version_conversion(p, True), to_test_protocols))
        output = self.multithreading_tests(self.test, binary_protocol_versions)
        logging.info(f'{self.test_name} test done.')
        return output

    @abstractmethod
    def test(self, version):
        """
        Test the implemented vulnerability

        :param int version: SSL/TLS version to test on
        :return: Whether the test passed or not
        :rtype: bool
        """
        pass

    @staticmethod
    def multithreading_tests(function, protocol_binary_versions):
        """
        Run tests in parallel

        :param list protocol_binary_versions:
        :param function: Functions to be run
        :return: Whether the server is vulnerable
        :rtype: bool
        """
        # List that all the threads live
        futures = []
        output = False
        with cf.ThreadPoolExecutor(max_workers=len(protocol_binary_versions)) as executor:
            for version in protocol_binary_versions:
                # Submit test function
                futures.append(executor.submit(function, version))
            for done_future in cf.as_completed(futures):
                if done_future.result():
                    output = True
                    # Since one of the tests already proved the server is vulnerable,
                    # no need to wait for other tests
                    for future in futures:
                        future.cancel()
                    # If all tests are done just break
                    if all([future.done() for future in futures]):
                        break
        return output
