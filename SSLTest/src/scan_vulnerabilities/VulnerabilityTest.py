import concurrent.futures as cf
import logging
from abc import ABC, abstractmethod

from ..scan_parameters.connections.connection_utils import worst_or_best_protocol
from ..utils import protocol_version_conversion

log = logging.getLogger(__name__)


class VulnerabilityTest(ABC):
    test_name = ''

    def __init__(self, supported_protocols, address, timeout, protocol):
        self.timeout = timeout
        self.address = address
        self.protocol = protocol
        self.supported_protocols = supported_protocols
        self.valid_protocols = []
        self.scan_once = True

    def scan(self):
        """
        Call the appropriate scan methods

        :return: Result of a scan
        :rtype: bool
        """
        log.info(f'Testing for {self.test_name}')
        usable_protocols = [p for p in self.supported_protocols if p in self.valid_protocols]
        switcher = {
            True: self.scan_for_protocol,
            False: self.scan_for_protocols
        }
        result = switcher[self.scan_once](usable_protocols)
        log.info(f'{self.test_name} test done.')
        return result

    def scan_for_protocol(self, usable_protocols):
        """
        Test the webserver for a vulnerability on a protocol versions

        :param: list usable_protocols
        :return: Whether a test was positive
        :rtype: bool
        """
        protocol = self.protocol
        if self.protocol not in self.valid_protocols:
            log.warning(f"{self.protocol} not valid for {self.test_name}, choosing best or worst protocol")
            protocol = worst_or_best_protocol(usable_protocols, False)
        protocol_to_test = protocol_version_conversion(protocol)
        result = self.test(protocol_to_test)
        return result

    def scan_for_protocols(self, usable_protocols):
        """
        Test the webserver for a vulnerability on all valid protocol versions

        :param: list usable_protocols
        :return: Whether any test was positive
        :rtype: bool
        """
        self.run_once()
        if 'TLSv1.1' in self.supported_protocols and 'TLSv1.0' in self.supported_protocols:
            self.supported_protocols.remove('TLSv1.1')
        if len(usable_protocols) == 0:
            log.warning(f"No usable protocols found for {self.test_name}")
            return False
        protocol_versions_numbers = list(map(protocol_version_conversion, usable_protocols))
        results = self.multithreading_tests(self.test, protocol_versions_numbers)
        return any(results)

    @staticmethod
    def multithreading_tests(function, protocol_binary_versions):
        """
        Run tests in parallel

        :param list protocol_binary_versions:
        :param function: Functions to be run
        :return: Results of the scans
        :rtype: list
        """
        # List that all the threads live
        futures = []
        results = []
        log.info(f"Creating {len(protocol_binary_versions)} threads for vulnerability tests")
        with cf.ThreadPoolExecutor(max_workers=len(protocol_binary_versions)) as executor:
            for version in protocol_binary_versions:
                # Submit test function
                futures.append(executor.submit(function, version))
            for done_future in cf.as_completed(futures):
                results.append(done_future.result())
        return results

    @abstractmethod
    def test(self, version):
        """
        Test the implemented vulnerability

        :param int version: SSL/TLS version to test on
        :return: Whether the test passed or not
        :rtype: bool
        """
        pass

    def run_once(self):
        """
        Vulnerability test will implement this function if some action is needed before the testing

        e.g. Drown SSLv2 scanning
        """
        pass
