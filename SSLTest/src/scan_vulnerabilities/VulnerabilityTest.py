import logging
import concurrent.futures as cf

from abc import ABC, abstractmethod


class VulnerabilityTest(ABC):
    def __init__(self, supported_protocols, address):
        self.test_name = ''
        self.timeout = 2
        self.address = address
        self.valid_protocols = []
        self.supported_protocols = supported_protocols
        self.protocol_binary_version = {
            "TLSv1.3": 0x04,
            "TLSv1.2": 0x03,
            "TLSv1.1": 0x02,
            "TLSv1.0": 0x01,
            "SSLv3": 0x00
        }

    def scan(self):
        """
        Test the webserver for a vulnerability on all valid protocol versions

        :return: Whether any test was positive
        :rtype: bool
        """
        logging.info(f'Testing for {self.test_name}...')
        to_test_protocols = filter(lambda protocol: protocol in self.valid_protocols, self.supported_protocols)
        binary_protocol_versions = list(map(lambda p: self.protocol_binary_version[p], to_test_protocols))
        output = self.multithreading_tests(self.test, binary_protocol_versions)
        logging.info(f'{self.test_name} test done.')
        return output

    @abstractmethod
    def test(self, version):
        pass

    @staticmethod
    def multithreading_tests(function, protocol_binary_version):
        """
        Run tests in parallel

        :param protocol_binary_version:
        :param function: Functions to be run
        :return: Whether the server is vulnerable
        :rtype: bool
        """
        # List that all the threads live
        futures = []
        output = False
        with cf.ThreadPoolExecutor(max_workers=len(protocol_binary_version)) as executor:
            for version in protocol_binary_version:
                # Submit test function
                futures.append(executor.submit(function, version))
            for done_future in cf.as_completed(futures):
                if done_future.result():
                    output = True
                    # Since one of the tests already proved the server is vulnerable,
                    # no need to wait for other tests
                    for future in futures:
                        future.cancel()
                    # If all tests are done just break
                    if all([future.done() for future in futures]):
                        break
        return output
